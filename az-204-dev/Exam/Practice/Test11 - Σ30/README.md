# Test11 - Î£30

---

## Questions
|n|Question|Answer|
|-|--------|------|
|1|You have an App Service with several instances. You notice the setting ARR Affinity is enabled on the General Settings page. What does ARR Affinity do when enabled?<br/><br/>a. Ensure that the client is always routed to the same instance for the life of the session<br/>b. Optional command-line arguments for the script processor<br/>c. Require client certificates in mutual authentication<br/>d. Keeps the app loaded even when there's no traffic|<details><summary>Answer</summary>a. Ensure that the client is always routed to the same instance for the life of the session<br/><br/>|<details><summary>Answer</summary>a. Durable functions<br/><br/>Durable Functions is an extension of Azure Functions that lets you write stateful functions in a serverless compute environment. The extension lets you define stateful workflows by writing orchestrator functions and stateful entities by writing entity functions using the Azure Functions programming model. Behind the scenes, the extension manages state, checkpoints, and restarts for you, allowing you to focus on your business logic. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/azure-functions/durable/durable-functions-overview?tabs=csharp</details>|</details>|
|2|What Azure Functions library do you need to implement in order for Functions to be able to call other Functions?<br/><br/>a. Durable functions<br/>b. Premium Tier Functions<br/>c. Extension Bundles<br/>d. Core Tools|<details><summary>Answer</summary>True</details>|
|3|Azure App Service has options to scale up and scale out. What does scaling out an app do?<br/><br/>a. Increases the number of VM instances that run your app<br/>b. Moves to the next higher App Service Plan, such as going from S1 Standard plan to S2 Standard plan<br/>c. Deploys another instance of your app to adifferent region to ensure better performance for global customers<br/>d. Adds additional running versions of your app to the same instance|<details><summary>Answer</summary>a. Increase the number of VM instances that run your app<br/><br/>Scale out: Increase the number of VM instances that run your app. You can scale out to as many as 30 instances, depending on your pricing tier. App Service Environments in Isolated tier further increases your scale-out count to 100 instances. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/manage-scale-up</details>|
|4|If you want to use nested ARM templates - have one ARM template include the contents of another template in it's deployment, what resource type do you use?<br/><br/>.a "dependsOn": [...]<br/>b. Microsoft.Resources/deploymentScripts<br/>c. Microsoft.Compute/virtualMachines/extensions<br/>d. Microsoft.Resources/deployments|<details><summary>Answer</summary>d. Microsoft.Resources/deployments<br/><br/>To deploy complex solutions, you can break your Azure Resource Manager template (ARM template) into many related templates, and then deploy them together through a main template. The related templates can be separate files or template syntax that is embedded within the main template. To link a template, add a deployments resource to your main template. In the templateLink property, specify the URI of the template to include. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/linked-templates?tabs=azure-powershell</details>|
|5|Which Azure Architecture pattern is specifically designed to increase application performance using a cache service?<br/><br/>a. Static content hosting pattern<br/>b. Sharding pattern<br/>c. Sidecar pattern<br/>d. Cache-aside pattern|<details><summary>Answer</summary>d. Cache-aside pattern<br/><br/>The name gives it away. The Cache-Aside pattern is designed to load data on demand into a cache from a data store. This can improve performance and also helps to maintain consistency between data held in the cache and data in the underlying data store.  Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside</details>|
|6|What is the Azure CLI command to create an Azure Container Instance? Fill in the blank. az _______ _______ --resource-group myResourceGroup --name mycontainer --image mcr.microsoft.com/azuredocs/aci-helloworld --dns-name-label aci-demo --ports 80<br/><br/>a. aci create<br/>b. container aci<br/>c. container create<br/>d. create container|<details><summary>Answer</summary>c. container create<br/><br/>az container create will create a new container instance. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/container-instances/container-instances-quickstart</details>|
|7|What does the Azure Container Registry endpoint look like?<br/><br/>a. registry.azure.com<br/>b. myprivateacr.eastus.azurecr.io<br/>c. myprivateacr.azurecr.io<br/>d. azurecr.io/myprivateacr|<details><summary>Answer</summary>c. myprivateacr.azurecr.io<br/><br/>azurecr.io is the general domain name for ACR, and myprivateacr.azurecr.io points to your own private registry (where myprivateacr is the name of your unique registry). Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-portal</details>|
|8|Azure App Service has options to scale up and scale out. What does scaling up an app do?<br/><br/>a. Switches the VM type your App Service runs on, to one with more vCPUs & more memory.<br/>b. It moves your App Service plan to a higher pricing tier, giving you more CPU, memory, disk space & extra features<br/>c. Deploys another instance of your app to a different region to ensure better performance for global customers<br/>d. Inceases the number of VM instances that run your app|<details><summary>Answer</summary>b. It moves your App Service plan to a higher pricing tier, giving you more CPU, memory, disk space & extra features<br/><br/>Scale up: Get more CPU, memory, disk space, and extra features like dedicated virtual machines (VMs), custom domains and certificates, staging slots, autoscaling, and more. You scale up by changing the pricing tier of the App Service plan that your app belongs to. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/manage-scale-up</details>|
|9|Your function uses the following code. You want to add a message to the log when the function starts late. What code belongs in the missing line? [FunctionName("TimerTriggerCSharp")] public static void Run([TimerTrigger("0 */5 * * * *")]TimerInfo myTimer, ILogger log) { >>>>> LINE MISSING HERE <<<<< { log.LogInformation("Timer is running late!"); } log.LogInformation($"C# Timer trigger function executed at: {DateTime.Now}");}<br/><br/>a. if (myTimer.IsPastDue)<br/>b. if (myTimer.TriggerTime < DateTime.Now)<br/>c. if (myTimer.IsLate)<br/>d. if (TimerTrigger.IsLate)|<details><summary>Answer</summary>a. if (myTimer.IsPastDue)<br/><br/>if (myTimer.IsPastDue) is the correct answer. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer?tabs=csharp#ncrontab-expressions</details>|
|10|When creating a Cosmos DB account, you indicate which consistency level you would like to follow: Strong, Bounded Staleness, Session, Consistent Prefix and Eventual. How can a developer force Strong consistency on a query when the database itself is Eventual consistency?<br/><br/>a. Set the ConsistencyLevel property of QueryRequestOptions when making the query<br/>b. Set the MaxConcurrency property of QueryRequestOptions when making the query<br/>c. By specifying the exact partition key & row key in the query<br/>d. Modify the Consistency level of the database using settings before making the query|<details><summary>Answer</summary>a. Set the ConsistencyLevel property of QueryRequestOptions when making the query<br/><br/>QueryRequestOptions.ConsistencyLevel Property gets or sets the consistency level required for the request in the Azure Cosmos DB service. This is a request level property, and doesn't affect the database settings. Refer to Microsoft Doc:<br/>https://docs.microsoft.com/en-us/dotnet/api/microsoft.azure.cosmos.queryrequestoptions.consistencylevel?view=azure-dotnet#Microsoft_Azure_Cosmos_QueryRequestOptions_ConsistencyLevel</details>|
|11|What is the concept of strong consistency with Cosmos DB?<br/><br/>a. Strong consistency means that, if two data writers were to try to update the data in a Cosmos DB container, the one who updated it last would win<br/>b. Strong consistency means that, across the world, two applications might read a data item from a Cosmos DB container at the same time & get different results<br/>c. With strong consistency, you are committing to use Cosmos DB in only one way in the future & forgoing other data storage models & APIs<br/>d. Strong consistency is that, across the world, readers are guranteed to always get the most recent committed version of an item|<details><summary>Answer</summary>d. Strong consistency is that, across the world, readers are guaranteed to always get the most recent committted version of an item<br/><br/>Strong consistency is that, across the world, readers are guaranteed to always get the most recent committed version of an item. A client will never see a partially committed item. See docs: https://docs.microsoft.com/en-us/azure/cosmos-db/consistency-levels</details>|
|12|Which type of data can most benefit from being stored in a caching system like Azure Redis Cache?<br/><br/>a. Data that remains relatively static<br/>b. Data that is called once in a session & never needed again (like a user passwor)<br/>c. Data that is constantly changing<br/>d. Data that is written & never read (like a log file)|<details><summary>Answer</summary>a. Data that remains relatively static<br/><br/>Data that is static benefits most from being cached, because you can use the cache to retrieve the data instead of having to go back to the original data source every time. Data that is written and never read does not need to be cached since caching only benefits reading. Data that is only ever used once by a session does not need to be cached as well since the first time the data is read, you have to go to the original source. So if you never need it a second time, you don't need to cache it. And data that is always changing (like a stock price) cannot be cached since you always have to go back to the original source to retrieve the latest. Refer to Microsoft Doc:<br/>https://docs.microsoft.com/en-us/azure/architecture/best-practices/caching?toc=%2fazure%2fredis-cache%2ftoc.json</details>|
|13|You have a Python app running in an Azure App Service and need to ensure that it is running on Python 3.10. Where in the Azure Portal do you set the Python version for an App Service?<br/><br/>a. App Service Plan > Apps<br/>b. Configuration > General Settings<br/>c. Settings > Properties<br/>d. Deployment > Deployment Center|<details><summary>Answer</summary>b. Configuration > General Settings<br/><br/>You can set the specific version of Python in Configuration > General Setting<br/>Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/configure-common</details>|
|14|How can you create a shared access signature and modify the expiry date and time after it's already been created?<br/><br/>a. You can edit the Shared Access Signature after it's been created in the SAS blade of the Storage Account<br/>b. Create the shared access signature using a stored access policy<br/>c. The only way to modify a SAS is to recreate it<br/>d. You can't modify the expiry data of a shared access signature in any way|<details><summary>Answer</summary>b. Create the shared access signature using a stored access policy<br/><br/>A shared access signature (SAS) provides secure delegated access to resources in your storage account. With a SAS, you have granular control over how a client can access your data. A stored access policy is defined on a resource container, which can be a blob container, table, queue, or file share. The stored access policy can be used to manage constraints for one or more service shared access signatures. When you associate a service SAS with a stored access policy, the SAS inherits the constraints-the start time, expiry time, and permissions-defined for the stored access policy. You can modify the stored access policy at any time after the SAS has been created. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview</details>|
|15|How many triggers can an Azure Function have?<br/><br/>a. Any number<br/>b. 0 or 1<br/>c. 32 maximum<br/>d. Exactly one|<details><summary>Answer</summary>d. Exactly one<br/><br/>Triggers are what cause a function to run. A trigger defines how a function is invoked and a function must have exactly one trigger. Triggers have associated data, which is often provided as the payload of the function. Refer to Microsoft Doc:<br/>https://docs.microsoft.com/en-us/azure/azure-functions/functions-triggers-bindings?tabs=csharp</details>|
|16|Your company uses Azure API Management as the public front-end to its APIs, to control access. You'd like to implement certificate authentication to ensure that only authorized clients are calling the API. In which policy section do you add the <authentication-certificate> policy?<br/><br/>a. Backend<br/>b. On-Error<br/>c. Inbound<br/>d. Outbound|<details><summary>Answer</summary>c. Inbound<br/><br/>Authentication is an inbound policy. Requests that fail to authenticate do not have the requests passed on to the API backend at all. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/api-management/api-management-authentication-policies</details>|
|17|What is the Azure CLI command to do live streaming of application log files?<br/><br/>a. Get-AzAppServiceLog<br/>b. az webapp log -all<br/>c. az webapp download<br/>d. az webapp log tail|<details><summary>Answer</summary>d. az webapp log tail<br/><br/>az webapp log will retrive the log, and the tail operator will read the last lines of the log and keep a live stream of it going. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/learn/modules/capture-application-logs-app-service/2-enable-and-configure-app-service-application-logging</details>|
|18|You have five applications installed on a single App Service Plan. Each application has two deployment slots - production and staging. You have scaled the plan out to three instances. How many VMs are running to support this?<br/><br/>a. Ten<br/>b. One<br/>c. Five<br/>d. Three|<details><summary>Answer</summary>d. Three<br/><br/>When you create an app in App Service, it is put into an App Service plan. When the app runs, it runs on all the VM instances configured in the App Service plan. If multiple apps are in the same App Service plan, they all share the same VM instances. If you have multiple deployment slots for an app, all deployment slots also run on the same VM instances. In this way, the App Service plan is the scale unit of the App Service apps. If the plan is configured to run five VM instances, then all apps in the plan run on all five instances. If the plan is configured for autoscaling, then all apps in the plan are scaled out together based on the autoscale settings. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/overview-hosting-plans</details>|
|19|Your Azure Web App is currently throwing a 500 server error when viewed. You'd like to see more detail on the error. In order to accomplish this, what app setting do you need to set, and to what value?<br/><br/>a. ENVIRONMENT = "Development"<br/>b. ASPNETCORE_ENVIRONMENT = "Development"<br/>c. LOGGING = "DEBUG"<br/>d. DEBUG = "TRUE"|<details><summary>Answer</summary>b. ASPNETCORE_ENVIRONMENT = "Development"<br/><br/>The development environment can enable features that shouldn't be exposed in production. If the environment isn't set, it defaults to Production, which disables most debugging features. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/configure-language-dotnetcore?pivots=platform-windows#access-environment-variables</details>|
|20|What is the URL for the Azure App Service Kudu companion app?<br/><br/>a. https://(app-name).kudu.azurewebsites.net<br/>b. ftp://(app-name).azurewebsites.net<br/>c. https://(app-name).scm.azurewebsites.net<br/>d. https://(app-name).azurewebsites.net|<details><summary>Answer</summary>c. https://(app-name).scm.azurewebsites.net<br/><br/>Kudu is the engine behind a number of features in Azure App Service related to source control based deployment, and other deployment methods like Dropbox and OneDrive sync. App not in Isolated tier uses https://(app-name).scm.azurewebsites.net, while apps in the isolated tier use https://(app-name).scm.(ase-name).p.azurewebsites.net. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/resources-kudu</details>|
|21|You've created a Cosmos DB account named Account1. Inside, you create one database named Db1, and one container named Container1. The data you are storing is document data using the Core (SQL) API. You have a new requirement to add a graph database using the Gremlin API. Can you create another database named Db2 inside Account1 for the graph data?<br/><br/>a. No, each account can only contain one type of data<br/>b. Yes, each database can use a different API in one account<br/>c. Yes, you can use any API to call Cosmos DB database of any type|<details><summary>Answer</summary>a. No, each account can only contain one type of data<br/><br/>The API determines the type of account to create. Azure Cosmos DB provides five APIs: Core (SQL) and MongoDB for document data, Gremlin for graph data, Azure Table, and Cassandra. Currently, you must create a separate account for each API. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/cosmos-db/account-databases-containers-items</details>|
|22|A Kubernetes cluster is dividend into which two components?<br/><br/>a. Control plane, Nodes<br/>b. Nodes, node pools<br/>c. Containers, Container groups<br/>d. Pods, nodes|<details><summary>Answer</summary>a. Control plane,Nodes<br/><br/>A Kubernetes cluster is divided into two components: 1. Control plane: provides the core Kubernetes services and orchestration of application workloads. 2. Nodes: run your application workloads. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/aks/concepts-clusters-workloads</details>|
|23|What advantage does the Compute-Optimized (Fsv2) instance family have over the General Purpose (Dsv4) instance family?<br/><br/>a. F-series VMs provide higher performance (ACU) per virtual CPU compared to D-series<br/>b. They provide more temporary disk space than D-series VMs<br/>c. F-series VMs are budget series, being much cheaper than D-series VMs<br/>d. F-series VMs allow you to scale to much more powerful machine sizes than D-series|<details><summary>Answer</summary>a. F-series VMs provide higher performance (ACU) per virtual CPU compared to D-series<br/><br/>The best advantage of the F-series VMs is that they provide faster performance per virtual CPU than the D-series. The machine hardware is designed for CPU performance. Pricing is actually comparable. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/virtual-machines/acu</details>|
|24|You have a Timer Trigger Function that uses "0 5 * * * *" as it's timer setting. How often will the function run?<br/><br/>a. Once every day, at 5:00 AM<br/>b. Every 5 minutes, every hour of the day<br/>c. That's an inalid expression & the function will not run<br/>d. Once every hour of the day, at 5 minutes after the hour|<details><summary>Answer</summary>d. Once every hour of the day,at 5 minutes after the hour<br/><br/>CRON uses a "{second} {minute} {hour} {day} {month} {day-of-week}" format for expressions. The first "0" means that it runs when the second equals 0. The second "5" means it will run at 5 minutes past the hour. The third "*" means that it will run every hour of every day. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer?tabs=csharp#ncrontab-expressions</details>|
|25|Once you enable App Service Logging in the Azure Portal, how long does Azure keep it on?<br/><br/>a. 2 hours<br/>b. 24 hours<br/>c. Until you disable it<br/>d. 12 hours|<details><summary>Answer</summary>d. 12 hours<br/><br/>App logs are the output of runtime trace statements in app code. For example, you might want to check some logic in your code by adding a trace to show when a particular function is being processed, or you might only want to see a logged message when a particular level of error has occurred. App logging is primarily for apps in pre-production and for troublesome issues, because excessive logs can carry a performance hit and quickly consume storage; for this reason, logging to the file system is automatically disabled after 12 hours. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/learn/modules/capture-application-logs-app-service/2-enable-and-configure-app-service-application-logging</details>|
|26|Which Azure technology allows you to implement infrastructure as code?<br/><br/>a. GitHub Actions<br/>b. ARM Templates<br/>c. Visual Studio Enterprise Edition<br/>d. Azure Automation Accounts|<details><summary>Answer</summary>b. ARM Templates<br/><br/>As infrastructure has become part of the iterative process, the division between operations and development has disappeared. Teams need to manage infrastructure and application code through a unified process. To implement infrastructure as code for your Azure solutions, use Azure Resource Manager templates (ARM templates). The template is a JavaScript Object Notation (JSON) file that defines the infrastructure and configuration for your project. The template uses declarative syntax, which lets you state what you intend to deploy without having to write the sequence of programming commands to create it. In the template, you specify the resources to deploy and the properties for those resources. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/overview</details>|
|27|In ASP.NET, how do you write a message to the application diagnostics log that only shows up when the user has enabled verbose level messages?<br/><br/>a. Trace.TraceWarning("message");<br/>b. Console.WriteLine("message");<br/>c. Trace.TraceLine("message");<br/>d. Trace.TraceInformation("message");|<details><summary>Answer</summary>c. Trace.WriteLine("message");<br/><br/>To log information to the app diagnostics log, use the System.Diagnostics.Trace class. There are four trace levels you can use, and these correlate with error, warning, information, and verbose logging levels shown in the Azure portal. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/learn/modules/capture-application-logs-app-service/2-enable-and-configure-app-service-application-logging</details>|
|28|You have an Azure App Service, with a WebJob. The WebJob is supposed to run continuously, but sometimes stops running as the App Service is unloaded when there are not enough incoming visitors. What can you do to ensure the App Service is never unloaded?<br/><br/>a. Set the Managed Pipeline version to Integrated<br/>b. Upgrade to Standard Service Plan<br/>c. Upgrade to Premium Service Plan<br/>d. Enable Always On setting on the General Settings page|<details><summary>Answer</summary>d. Enable Always On setting on the General<br/><br/>Always On: Keeps the app loaded even when there's no traffic. When Always On is not turned on (default), the app is unloaded after 20 minutes without any incoming requests. The unloaded app can cause high latency for new requests because of its warm-up time. When Always On is turned on, the front-end load balancer sends a GET request to the application root every five minutes. The continuous ping prevents the app from being unloaded. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/configure-common</details>|
|29|What type of App Service log files store the web server logs?<br/><br/>a. AllMetrics<br/>b. AppServiceHTTPLogs<br/>c. AppServiceAppLogs<br/>d. AppServiceAuditLogs|<details><summary>Answer</summary>b. AppServiceHTTPLogs<br/><br/>AppServiceHTTPLogs are web logs. AppServiceAppLogs are application logs. AppServiceAuditLogs contain login activity via FTP and kudu. And AllMetrics are not logs, but performance metrics. Refer to Microsoft Doc: https://docs.microsoft.com/en-us/azure/app-service/troubleshoot-diagnostic-logs</details>|
|30|Generally speaking, regardless of which region, which is the lowest cost redundancy option for Blob Storage?<br/><br/>a. GRS<br/>b. LRS<br/>c. GZRS<br/>d. ZRS|<details><summary>Answer</summary>b. LRS<br/><br/>Azure Storage always stores multiple copies of your data so that it is protected from planned and unplanned events, including transient hardware failures, network or power outages, and massive natural disasters. Redundancy ensures that your storage account meets its availability and durability targets even in the face of failures. Locally redundant storage (LRS) copies your data synchronously three times within a single physical location in the primary region. LRS is the least expensive replication option, but is not recommended for applications requiring high availability or durability. Refer to Microsoft Doc: https://azure.microsoft.com/en-ca/pricing/details/storage/blobs/</details>|

---

## Results
|n|Data|Score|Revison|
|-|----|-----|-------|
|1|06-09-2023 AM|17/30 = 56%||<details><summary>Revision</summary>True</details>|
|2|
